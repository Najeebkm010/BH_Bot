import discord
from discord.ext import commands
import subprocess
import os

TOKEN = 'Your Discord Token'
MAX_MESSAGE_LENGTH = 2000

intents = discord.Intents.default()
intents.message_content = True  # Enable the message content intent

bot = commands.Bot(command_prefix='!', intents=intents)

@bot.event
async def on_ready():
    print(f'We have logged in as {bot.user}')

@bot.command()
async def subs(ctx, domain: str):
    """Command to run subfinder and save results to a file"""
    subfinder_file = 'subfinder_results.txt'

    # Run subfinder and save results to a file
    try:
        with open(subfinder_file, 'w') as file:
            subfinder_process = subprocess.Popen(['./subfinder_scan.sh', domain], stdout=file, stderr=subprocess.PIPE)
            _, stderr = subfinder_process.communicate()
            if stderr:
                file.write("Errors:\n" + stderr.decode())
    except Exception as e:
        await ctx.send(f"Error running subfinder: {str(e)}")
        return

    # Send the subfinder results file
    try:
        with open(subfinder_file, 'rb') as file:
            await ctx.send(file=discord.File(file, subfinder_file))
    except Exception as e:
        await ctx.send(f"Error sending subfinder results file: {str(e)}")
    finally:
        # Clean up the file
        if os.path.exists(subfinder_file):
            os.remove(subfinder_file)

@bot.command()
async def nf(ctx, domain: str):
    """Command to run nf with a domain and send results"""
    nf_file = 'nf_results.txt'

    # Run nf with the domain
    try:
        with open(nf_file, 'w') as file:
            nf_process = subprocess.Popen(['./nf_scan.sh', domain], stdout=file, stderr=subprocess.PIPE)
            _, stderr = nf_process.communicate()
            if stderr:
                file.write("Errors:\n" + stderr.decode())
    except Exception as e:
        await ctx.send(f"Error running nf: {str(e)}")
        return

    # Check the size of the result file and either send it as text or as a file
    try:
        with open(nf_file, 'r') as file:
            nf_result = file.read()
            if len(nf_result) <= MAX_MESSAGE_LENGTH:
                await ctx.send(f"Results for `{domain}`:\n```{nf_result}```")
            else:
                await ctx.send(file=discord.File(nf_file))
    except Exception as e:
        await ctx.send(f"Error sending nf results: {str(e)}")
    finally:
        # Clean up the file
        if os.path.exists(nf_file):
            os.remove(nf_file)

@bot.command()
async def port(ctx, domain: str):
    """Command to run nmap and send results as a file"""
    result_file = 'nmap_results.txt'

    # Run nmap and save results to a file
    try:
        with open(result_file, 'w') as file:
            nmap_process = subprocess.Popen(['./nmap_scan.sh', domain], stdout=file, stderr=subprocess.PIPE)
            _, stderr = nmap_process.communicate()
            if stderr:
                file.write("Errors:\n" + stderr.decode())
    except Exception as e:
        await ctx.send(f"Error running nmap: {str(e)}")
        return

    # Send the file in a Discord message
    try:
        with open(result_file, 'rb') as file:
            await ctx.send(file=discord.File(file, result_file))
    except Exception as e:
        await ctx.send(f"Error sending file: {str(e)}")
    finally:
        # Clean up the file
        if os.path.exists(result_file):
            os.remove(result_file)

@bot.command()
async def xss(ctx, domain: str):
    """Command to run paramspider and pipe results to kxss"""
    safe_domain = domain.replace(":", "_")  # Handle edge cases like ports
    paramspider_output = f'results/{safe_domain}.txt'
    kxss_output_file = 'kxss_results.txt'

    try:
        # Run paramspider
        paramspider_process = subprocess.Popen(['paramspider', '-d', domain], stdout=subprocess.PIPE, stderr=subprocess.PIPE)
        _, paramspider_err = paramspider_process.communicate()

        # Check for real errors only
        decoded_err = paramspider_err.decode()
        if "Traceback" in decoded_err or "ERROR" in decoded_err.upper():
            await ctx.send(f"Paramspider error:\n```{decoded_err}```")

        # Save logs silently
        with open('paramspider_debug.log', 'w') as log_file:
            log_file.write(decoded_err)

        # Check if result file exists
        if not os.path.exists(paramspider_output):
            await ctx.send("No output generated by paramspider.")
            return

        # Run kxss
        with open(paramspider_output, 'r') as input_file, open(kxss_output_file, 'w') as output_file:
            kxss_process = subprocess.Popen(['kxss'], stdin=input_file, stdout=output_file, stderr=subprocess.PIPE)
            _, kxss_err = kxss_process.communicate()

            decoded_kxss_err = kxss_err.decode()
            if "Traceback" in decoded_kxss_err or "ERROR" in decoded_kxss_err.upper():
                output_file.write("\nKXSS error:\n" + decoded_kxss_err)

        # Read and send output
        with open(kxss_output_file, 'r') as result_file:
            result = result_file.read()
            if result.strip() == "":
                await ctx.send(f"No XSS reflections found for `{domain}`.")
            elif len(result) <= MAX_MESSAGE_LENGTH:
                await ctx.send(f"XSS reflections for `{domain}`:\n```{result}```")
            else:
                await ctx.send(file=discord.File(kxss_output_file))

    except Exception as e:
        await ctx.send(f"Error in XSS scan: {str(e)}")

    finally:
        if os.path.exists(kxss_output_file):
            os.remove(kxss_output_file)

@bot.command()
async def ip(ctx, domain: str):
    """Command to get IPs using getips.sh script"""
    result_file = 'ip_results.txt'

    try:
        # Run the getips.sh script
        with open(result_file, 'w') as file:
            ip_process = subprocess.Popen(['./getips.sh', domain], stdout=file, stderr=subprocess.PIPE)
            _, stderr = ip_process.communicate()
            if stderr:
                file.write("\nErrors:\n" + stderr.decode())

        # Read and send output
        with open(result_file, 'r') as file:
            result = file.read()
            if len(result.strip()) == 0:
                await ctx.send("No IP data was returned.")
            elif len(result) <= MAX_MESSAGE_LENGTH:
                await ctx.send(f"IPs for `{domain}`:\n```{result}```")
            else:
                await ctx.send(file=discord.File(result_file))

    except Exception as e:
        await ctx.send(f"Error running IP check: {str(e)}")

    finally:
        if os.path.exists(result_file):
            os.remove(result_file)


bot.run(TOKEN)
